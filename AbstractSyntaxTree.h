#pragma once

enum class Token  // Terminals (apart from operators) rename something else? they should probably be generated by the lexer when encountered
{
	Id,
	Int,
	LPar     = '(',
	RPar     = ')',
	Mul      = '*',
	Div      = '/',
	Sub      = '-',
	Add      = '+',
	Less     = '<',
	More     = '>', // { } & & | | %
	Assign   = '=',
};

template <typename Enumeration>
auto GetTokenValue(Enumeration const value) -> typename std::underlying_type<Enumeration>::type
{
	return static_cast<typename std::underlying_type<Enumeration>::type>(value);
}

// Base Node class
class ASTNode
{
public:
	ASTNode() {}
	virtual ~ASTNode() {}

	virtual void Print() = 0;
};
// Abstract Syntax Tree Node with one branch or leaf
class UnaryASTNode : public ASTNode
{
private:
	Token op;
	ASTNode* expr;
public:
	UnaryASTNode(Token t, ASTNode* n) : ASTNode(), op(t), expr(n) {}
	virtual ~UnaryASTNode() { delete expr; }

	virtual void Print()
	{
		std::cout << "Unary: '" << (char)GetTokenValue(op) << "' [";
		expr->Print();
		std::cout << "]";
	}
};
// Abstract Syntax Tree Node with two branches or leaves
class BinaryASTNode : public ASTNode
{
protected:
	ASTNode* left;
	ASTNode* right;
	Token op;
public:
	BinaryASTNode(ASTNode* l, Token o, ASTNode* r) : ASTNode(), left(l), op(o), right(r) {}
	virtual ~BinaryASTNode()
	{
		delete left;
		delete right;
	}

	virtual void Print() = 0;
};


// Node representing a number(integer) literal
class IntegerNode : public ASTNode       // this doesnt have a token anymore
{
private:
	int value;
public:
	IntegerNode(const std::string& val) : ASTNode(), value(std::stoi(val)) {}
	virtual ~IntegerNode() {}

	virtual void Print() override { std::cout << "Int: " << value; }
};
// Node representing an identifier
class IdentifierNode : public ASTNode    // this doesnt have a token anymore - NOT USED ATM ALSO
{
private:
	Token type;  // int atm but not used
	std::string value;
public:
	IdentifierNode(const std::string& val) : ASTNode(), value(val) {}
	virtual ~IdentifierNode() {}

	virtual void Print() override { std::cout << "Ident: " << value; }
};


// Node representing a binary operation (Addition, Subtraction, Multiplication or Division)
class BinaryOperationNode : public BinaryASTNode   // very similar print with condition
{
public:
	BinaryOperationNode(ASTNode* l, Token o, ASTNode* r) : BinaryASTNode(l, o, r) {}
	virtual ~BinaryOperationNode() {}

	virtual void Print() override
	{
		std::cout << "BinOp: '" << (char)GetTokenValue(op) << "' [L: ";
		left->Print();
		std::cout << " R: ";
		right->Print();
		std::cout << "]";
	}
};
class ConditionNode : public BinaryASTNode   // very similar print with binaryOperator
{
public:
	ConditionNode(ASTNode* l, Token o, ASTNode* r) : BinaryASTNode(l, o, r) {}
	virtual ~ConditionNode() {}

	virtual void Print() override
	{
		std::cout << "COND: '" << (char)GetTokenValue(op) << "' [L: ";
		left->Print();
		std::cout << " R: ";
		right->Print();
		std::cout << "]";
	}
};

// this should inherit from a ternary ASTNode
class IfNode : public ASTNode
{
private:
	ASTNode* condition;
	ASTNode* body;
public:
	IfNode(ASTNode* cond, ASTNode* b) : ASTNode(), condition(cond), body(b) {}
	virtual ~IfNode()
	{
		delete condition;
		if (body) delete body;
	}

	virtual void Print() override
	{
		std::cout << "\nIF: " << "[";
		condition->Print();
		std::cout << " BODY: ";
		// If body can be empty
		if (body) body->Print();
		std::cout << "]";
	}
};
class WhileNode : public ASTNode  // copy of if right now - if will change later
{
private:
	ASTNode* condition;
	ASTNode* body;
public:
	WhileNode(ASTNode* cond, ASTNode* b) : ASTNode(), condition(cond), body(b) {}
	virtual ~WhileNode()
	{
		delete condition;
		if (body) delete body;
	}

	virtual void Print() override
	{
		std::cout << "\nWHILE: " << "[";
		condition->Print();
		std::cout << " BODY: ";
		// If body can be empty
		if (body) body->Print();
		std::cout << "]";
	}
};
class CompoundStatementNode : public ASTNode  // subclass same with some other?
{
private:
	std::vector<ASTNode*> statements;
public:
	CompoundStatementNode() : ASTNode() {}
	virtual ~CompoundStatementNode() { for (const auto& statement : statements) delete statement; }

	void Push(ASTNode* statement) { statements.push_back(statement); }
	virtual void Print() override { for (const auto& statement : statements) statement->Print(); }
};
class AssignStatementNode : public BinaryASTNode
{
public:
	AssignStatementNode(IdentifierNode* ident, ASTNode* expr) : BinaryASTNode(ident, Token::Assign, expr) {}
	virtual ~AssignStatementNode() {}

	virtual void Print() override
	{
		std::cout << "\nASSIGN: '" << (char)GetTokenValue(op) << "' [L: ";
		left->Print();
		std::cout << " R: ";
		right->Print();
		std::cout << "]";
	}
};
class EmptyStatementNode : public ASTNode
{
public:
	EmptyStatementNode() : ASTNode() {}
	virtual ~EmptyStatementNode() {}

	virtual void Print() override { }//std::cout << " "; }
};